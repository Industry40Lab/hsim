import sched
import threading
import time
import trio
import sched
import time
from typing import Callable, Iterable, Union
import numpy as np


class Event:
    def __init__(self, env, callbacks: Union[Callable, Iterable[Callable], None] = None):
        self._event = trio.Event()
        self.env = env
        if isinstance(callbacks, Iterable):
            for cb in callbacks:
                self.add_callback(cb)
        elif callable(callbacks):
            self.add_callback(callbacks)

    def trigger(self):
        self._event.set()
        print(f"Event triggered at simulated time {self.env.current_time}")
        if isinstance(self._callbacks, Iterable):
            for cb in self._callbacks:
                cb() 
        else:
            self._callbacks()
    async def wait(self):
        await self._event.wait()

    def __getstate__(self):
        state = self.__dict__.copy()
        if '_loop' in state:
            state['_loop'] = None
        return state

    def __setstate__(self, state):
        self.__dict__.update(state)


class Scheduler(sched.scheduler):
    def __init__(self, timefunc, delayfunc):
        super().__init__(timefunc, delayfunc)
        self._lock = threading.RLock()
    def __getstate__(self):
        state = self.__dict__.copy()
        state['_lock'] = None
        return state
    def __setstate__(self, state):
        self.__dict__.update(state)
        self._lock = threading.RLock()


class Environment:
    _termination : trio.Event
    def __init__(self):
        self.scheduler = Scheduler(timefunc=self._get_time, delayfunc=self.delay)
        self.current_time = 0
        self.until = 0
        self._termination = trio.Event()
        self._objects = []
    def _get_time(self):
        return self.current_time
    @property
    def now(self):
        return self.current_time
    def delay(self, duration):
        time.sleep(duration)
    def advance_time(self, seconds):
        self.current_time += seconds
        self.scheduler.run(blocking=False)
    def end_simulation(self):
        self._termination.set()
    def check_conditions(self):
        for event in self.scheduler.queue:
            event.check() if isinstance(event, ConditionEvent) else None
    async def run(self,until=0):
        until = self.until
        self._termination = trio.Event()
        self.scheduler.enter(until, 1, self.end_simulation)  
        while not self._termination.is_set():
            if self.scheduler.queue:
                next_event_time = self.scheduler.queue[0].time
                time_to_advance = next_event_time - self.current_time
            else:
                print("No more events to process at time {self.now}")
                break
            self.advance_time(time_to_advance)
            print(f"Simulated time: {self.current_time}")
            await trio.sleep(0)  # Yield control to allow other tasks to run
      

class var:
    def __init__(self, initial_value=None):
        self._value = initial_value
        self._callbacks = []
    @property
    def value(self):
        return self._value
    @value.setter
    def value(self, new_value):
        self._value = new_value
        if hasattr(self, "env"):
            self._callback()
    def __imatmul__(self, other):
        self.value = other
        return self
    def _callback(self):
        self.env.check_conditions()


class Timeout(Event):
    def __init__(self, env, timeout):
        super().__init__(env)
        self.timeout = timeout
        self.env.scheduler.enterabs(env.now + timeout, 1, self.trigger_timeout)
        print(f"Timeout set for {timeout} seconds at simulated time {self.env.current_time}")
    def trigger_timeout(self):
        self._event.set()
        print(f"Timeout of {self.timeout} seconds reached at simulated time {self.env.current_time}")
    async def wait(self):
        await super().wait()
        self._event = trio.Event()


class ConditionEvent(Event):
    def __init__(self, env, condition: Callable[[], bool], callbacks: Union[Callable, Iterable[Callable], None] = None):
        super().__init__(env, callbacks)
        self._condition = condition

    def check(self):
        if self.condition():
            self.trigger()


class Message(Event):
    def __init__(self, env, message, destination):
        super().__init__(env, callbacks=None)
        self.message = message

    def trigger(self):
        super().trigger()
        print(f"Message: {self.message}")


def class_binder(self, cls):
    def wrapper(*args, **kwargs):
        return cls(self, *args, **kwargs)
    return wrapper        

       
if __name__ == "__main__":
    try: 
        async def test():
            env = Environment()
            # Create a Timeout event with a 5-second timeout
            timeout = Timeout(env, 5)
            # Run the simulated clock until a specified time and wait for its completion
            await env.run(until=10)
            import pickle
            env = pickle.loads(pickle.dumps(env))
            await env.run(until=15)
            print("Environment has completed running.")
        trio.run(test)
    except Exception as e:
        print(e)
        print("Error in test")

